
import networkx as nx
import numpy as np


def fill_hydrogens(graph, max_bonds=4):
    """
    Function to add hydrogens to a molecular graph. Requires the
    connectivity matrix, which is used to calculate the number of
    bonds on each atom. The function loops over each atom, and
    adds hydrogens until the maximum number of bonds is fulfilled.
    """
    h_counter = hydrogen_generator()
    for node in list(graph.nodes):
        nbonds = sum_bonds(graph, node)
        while nbonds < max_bonds:
            h_atom = next(h_counter)
            graph.add_node(h_atom)
            graph.add_edge(node, h_atom, weight=3)
            nbonds += 1


def hydrogen_generator():
    """
    A generator for keeping track of hydrogen counts. No input is
    required, and calling next will give you the next hydrogen to
    add as a node to a molecular graph.
    :return: hydrogen_generator generator object
    """
    n = 0
    while n < 100:
        yield "H{}".format(n)
        n+=1


def inverse_weighting(sums, threshold=3.):
    """
    Calculate probability weights of adding bonds to neighbors
    based on its current bonding situation. The weighting
    is calculated as the inverse of the number of bonds, and
    any neighbor with 3 or more bonds are set with a large number
    such that the inverse weighting goes to zero.

    :param sums: numpy 1D array with sums as elements.
    :return norm_inv: numpy 1D array with normalized inverse weights
    """
    # Make neighbors with 3 or more bonds basically impossible to bond with
    sums[sums <= threshold] = 1e9
    # Inverse weighting
    inverse = np.divide(1., sums)
    norm_inv = inverse / np.sum(inverse)
    return norm_inv


def sum_bonds(graph, node):
    """
    Calculate the number of bonds for a given atom in a molecular graph.
    :param graph: Graph object
    :param node: str reference to a node in the specified Graph
    :return bond_sum: float number of bonds
    """
    bond_sum = np.sum(
        [graph[node][neighbor]["weight"] for neighbor in nx.neighbors(graph, node)]
    )
    return bond_sum


def node_sums(graph, node):
    """
    Calculate the number of bonds the neighboring nodes have for a given
    node.
    """
    node_sum = sum_bonds(graph, node)
    neighbors = nx.neighbors(graph, node)
    neighbor_sum = np.array([sum_bonds(graph, neighbor) for neighbor in neighbors])
    return node_sum, neighbor_sum


def pos2xyz(positions, comment):
    """
    Takes the positions generated by NetworkX and formats it into xyz format.
    """
    natoms = len(positions)
    xyz = "{}\n".format(natoms)
    xyz += "{}\n".format(comment)
    for atom, coords in positions.items():
        coords = np.array2string(coords, precision=6, suppress_small=True, separator=" ")
        for bracket in ['''[''', ''']''']:
            coords = coords.replace(bracket, "")
        xyz += "{} {}\n".format(atom[0], coords)
    return xyz
