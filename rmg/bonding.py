
import networkx as nx
import numpy as np
import periodictable


def fill_hydrogens(graph, max_bonds=4):
    """
    Function to add hydrogens to a molecular graph. Requires the
    connectivity matrix, which is used to calculate the number of
    bonds on each atom. The function loops over each atom, and
    adds hydrogens until the maximum number of bonds is fulfilled.
    """
    h_counter = hydrogen_generator()
    for node in list(graph.nodes):
        nbonds = sum_bonds(graph, node)
        while nbonds < max_bonds:
            h_atom = next(h_counter)
            graph.add_node(h_atom)
            graph.add_edge(node, h_atom, weight=3)
            nbonds += 1


def hydrogen_generator():
    """
    A generator for keeping track of hydrogen counts. No input is
    required, and calling next will give you the next hydrogen to
    add as a node to a molecular graph.
    :return: hydrogen_generator generator object
    """
    n = 0
    while n < 100:
        yield "H{}".format(n)
        n+=1


def inverse_weighting(sums, threshold=3.):
    """
    Calculate probability weights of adding bonds to neighbors
    based on its current bonding situation. The weighting
    is calculated as the inverse of the number of bonds, and
    any neighbor with 3 or more bonds are set with a large number
    such that the inverse weighting goes to zero.

    :param sums: numpy 1D array with sums as elements.
    :return norm_inv: numpy 1D array with normalized inverse weights
    """
    # Make neighbors with 3 or more bonds basically impossible to bond with
    sums[sums <= threshold] = 1e9
    # Inverse weighting
    inverse = np.divide(1., sums)
    norm_inv = inverse / np.sum(inverse)
    return norm_inv


def sum_bonds(graph, node):
    """
    Calculate the number of bonds for a given atom in a molecular graph.
    :param graph: Graph object
    :param node: str reference to a node in the specified Graph
    :return bond_sum: float number of bonds
    """
    bond_sum = np.sum(
        [graph[node][neighbor]["weight"] for neighbor in nx.neighbors(graph, node)]
    )
    return bond_sum


def node_sums(graph, node):
    """
    Calculate the number of bonds the neighboring nodes have for a given
    node.
    """
    node_sum = sum_bonds(graph, node)
    neighbors = nx.neighbors(graph, node)
    neighbor_sum = np.array([sum_bonds(graph, neighbor) for neighbor in neighbors])
    return node_sum, neighbor_sum


def pos2xyz(positions, comment):
    """
    Takes the positions generated by NetworkX and formats it into xyz format.
    """
    natoms = len(positions)
    xyz = "{}\n".format(natoms)
    xyz += "{}\n".format(comment)
    for atom, coords in positions.items():
        coords = np.array2string(coords, precision=6, suppress_small=True, separator=" ")
        for bracket in ['''[''', ''']''']:
            coords = coords.replace(bracket, "")
        xyz += "{} {}\n".format(atom[0], coords)
    return xyz


def calc_distance(A, B):
    """
    Calculate the distance between two vectors.
    :param A: numpy 1D array
    :param B: numpy 1D array
    :return dist: distance between A and B
    """
    dist = np.linalg.norm(B - A)
    return dist


def new_length(A, B, new_dist):
    """
    Calculate a new vector that replaces B with a new distance.
    :param A: numpy 1D array
    :param B: numpy 1D array
    :param new_dist: new value for the distance between A and the new vector
    :return new_vector: numpy 1D array
    """

    factor = new_dist / calc_distance(A, B)
    distance = A - B
    new_vector = (distance * factor) + A
    return new_vector


def centerofmass(coord_dict):
    """
    Calculate the center of mass coordinates by providing a coordinate dictionary
    generated by the spring_layout function. Keys are atoms with prefixes, and
    values are numpy 1D arrays corresponding to coordinates.
    :param coord_dict: dict of coordinates
    :return com_coords: numpy 1D array corresponding to the center-of-mass coordinates
    """
    xyz_list = [
        [periodictable.formula(atom[0]).mass, coords] for atom, coords in coord_dict.items()
    ]
    mass_weighted = np.array([row[0] * row[1] for row in xyz_list])
    mass_sum = np.sum(row[0] for row in xyz_list)
    com_coords = (1. / mass_sum) * np.sum(mass_weighted)
    return com_coords


def harmonic_spring(x, x0=1.42, k=2):
    """
    Calculate the potential energy of
    """
    dist = x - x0
    return 0.5 * k * (dist)**2.


def harmonic_deriv(x, x0=1.42, k=2):
    dist = np.linalg.norm(x - x0)
    return dist * k


def node_energy_force(node, graph, coords):
    bonds = {
        1: 1.443,
        2: 1.345,
        3: 1.2652,
    }
    neighbors = nx.neighbors(graph, node)
    # If atom isn't hydrogen, then we look up the standard distances.
    ideal_dists = [
        bonds[graph[node][neighbor]["weight"]] if "H" not in neighbor else 1.01 for neighbor in neighbors
    ]
    node_coord = coords[node]
    distances = [
        calc_distance(node_coord, coords[neighbor]) for neighbor in neighbors
    ]
    energies = np.sum([harmonic_spring(dist, ideal) for dist, ideal in zip(distances, ideal_dists)])
    forces = np.sum([harmonic_deriv(dist, ideal) for dist, ideal in zip(distances, ideal_dists)])
    return energies, forces


def optimizer